import streamlit as st
import plotly.graph_objects as go
from plotly.subplots import make_subplots 
import math
from sympy import symbols, Eq, solve, N
import pandas as pd

# -------------------------------------------------
# 1ï¸âƒ£  Default sessionâ€‘state values (run only once)
# -------------------------------------------------
if "STEP_SEC" not in st.session_state:
    st.session_state.STEP_SEC = 0.02          # seconds per step
if "TOTAL_TIME" not in st.session_state:
    st.session_state.TOTAL_TIME = 10         # total simulation time (seconds)
if "PLATEN_RPM" not in st.session_state:
    st.session_state.PLATEN_RPM = 86
if "POINTA_RPM" not in st.session_state:
    st.session_state.POINTA_RPM = 92
if "POINTA_RADIUS" not in st.session_state:
    st.session_state.POINTA_RADIUS = 100

# pendulumâ€‘related defaults
if "SWEEP_START" not in st.session_state:
    st.session_state.SWEEP_START = 7.2      # inch
if "SWEEP_END" not in st.session_state:
    st.session_state.SWEEP_END   = 8.2      # inch
if "SWPS_MIN" not in st.session_state:
    st.session_state.SWPS_MIN    = 13
if "PEND_MODE" not in st.session_state:
    st.session_state.PEND_MODE   = "Sine"   # or "Custom"

# -------------------------------------------------
# 2ï¸âƒ£  Sidebar input form
# -------------------------------------------------
st.sidebar.header("Setting")
with st.sidebar.form(key="param_form"):
    st.session_state.PLATEN_RPM = st.number_input(
        "Platen RPM", min_value=0, max_value=200, value=st.session_state.PLATEN_RPM, step=1
    )
    st.session_state.POINTA_RPM = st.number_input(
        "Head RPM", min_value=0, max_value=200, value=st.session_state.POINTA_RPM, step=1
    )
    st.session_state.POINTA_RADIUS = st.number_input(
        "PointA Radius (mm)", min_value=1, max_value=150, value=st.session_state.POINTA_RADIUS, step=1
    )
    st.session_state.STEP_SEC = st.slider(
        "second per STEP", min_value=0.01, max_value=0.1,
        value=st.session_state.STEP_SEC, step=0.01, format="%.2f"
    )
    st.session_state.TOTAL_TIME = st.slider(
        "TOTAL_TIME (s)", min_value=1, max_value=99,
        value=int(st.session_state.TOTAL_TIME), step=1
    )
    st.session_state.SWEEP_START = st.slider(
        "Sweep START (inch)", min_value=6.0, max_value=7.3,
        value=float(st.session_state.SWEEP_START), step=0.1, format="%.2f"
    )
    st.session_state.SWEEP_END = st.slider(
        "Sweep END (inch)", min_value=8.0, max_value=8.4,
        value=float(st.session_state.SWEEP_END), step=0.1, format="%.2f"
    )
    st.session_state.SWPS_MIN = st.slider(
        "Swps per minute", min_value=13, max_value=20,
        value=int(st.session_state.SWPS_MIN), step=1
    )
    st.session_state.PEND_MODE = st.selectbox(
        "Sweep mode", options=["Sine", "Custom(1)"],
        index=0 if st.session_state.PEND_MODE == "Sine" else 1
    )
    st.session_state.SHOW_GREEN = st.checkbox(
    "Show point 2",
    value=True,
    key="show_green_checkbox"
    )
    submitted = st.form_submit_button("Update")
    if submitted:
        st.session_state.show_plot = True   # flag to draw the figure

# -------------------------------------------------
# 3ï¸âƒ£  Placeholder / info (before Update)
# -------------------------------------------------
if not st.session_state.get("show_plot", False):
    st.info(
        "Set the parameters on the left sidebar and click **Update** to generate the plot.\n"
        "âš ï¸ If second_per_STEP is very small or TOTAL_TIME is large, many points will be created "
        "and rendering may take several mins."
    )
    st.stop()   # stop execution until the user clicks Update

# -------------------------------------------------
# 4ï¸âƒ£  Derived constants
# -------------------------------------------------
STEP_SEC   = st.session_state.STEP_SEC
TOTAL_TIME = st.session_state.TOTAL_TIME
STEPS_TOTAL = int(TOTAL_TIME / STEP_SEC) + 1   # +1 so the final time is included

if STEPS_TOTAL > 1000:
    st.warning(
        "âš ï¸over 1000 steps --- "
        "please retry with SMALLER total_time or BIGGER second_per_step.")
    st.stop() 

# degrees added each step (RPM Ã— 6Â°/s Ã— STEP_SEC)
deg_per_step_platen = st.session_state.PLATEN_RPM * 6.0 * STEP_SEC
deg_per_step_pointa = st.session_state.POINTA_RPM * 6.0 * STEP_SEC

# pendulum frequency (swings per minute â†’ cycles per step)
WAFER_PENDULUM_FREQ = st.session_state.SWPS_MIN * STEP_SEC / 30

# waferâ€‘center sweep range (inch â†’ mm)
WAFER_NEAR = st.session_state.SWEEP_START * 2.54 * 10   # mm
WAFER_FAR  = st.session_state.SWEEP_END   * 2.54 * 10   # mm
WAFER_MID  = (WAFER_NEAR + WAFER_FAR) / 2.0
WAFER_AMP  = (WAFER_FAR - WAFER_NEAR) / 2.0

PLATEN_RADIUS = 390   

Disk_Near_ini = 2.7 * 25.4   # 68.58 mm
Disk_Far_ini = 14.7 * 25.4  # 373.38 mm

# -------------------------------------------------
# 5ï¸âƒ£  Containers for all points
# -------------------------------------------------
pa_x, pa_y   = [], []          # blue PointA
pa2_x, pa2_y = [], []          # green PointA2 (opposite side)
pl_x, pl_y   = [], []          # black Platen
wa_x_traj, wa_y_traj = [], []  # waferâ€‘center trajectory (list of floats)
platen_rev = []   # Platen revolutions (float, 1â€‘decimal)
wafer_rev  = []   # Waferâ€‘center revolutions (float, 1â€‘decimal)

# distanceâ€‘vsâ€‘step data (distance from origin)
dist_a1, dist_a2, dist_wa = [], [], []   # each list length = STEPS_TOTAL


k_x, k_y = [], []          # K ì  ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
j_x, j_y = [], []          # J ì  ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
disk_n_x, disk_n_y= [], []
disk_f_x, disk_f_y= [], []        

# -------------------------------------------------
# 6ï¸âƒ£  Main loop â€“ compute every step
# -------------------------------------------------

def calc_axis_rot(x, y, deg=45):
    rad = math.radians(deg)
    cos_a, sin_a = math.cos(rad), math.sin(rad)
    x_p = x * cos_a - y * sin_a
    y_p = x * sin_a + y * cos_a
    return x_p, y_p

def solve_joint(r, Xx, Xy, name="J"):
    x, y = symbols('x y', real=True)
    eq1 = Eq(x**2 + y**2, r**2)
    eq2 = Eq((x - Xx)**2 + (y - Xy)**2, 610**2)
    sol = solve((eq1, eq2), (x, y), dict=True)
    valid = []
    for s in sol:
        xv = N(s[x])
        yv = N(s[y])
        if xv > 0 and yv < 0:            
            valid.append((float(xv), float(yv)))
    if not valid:
        raise ValueError(f"{name} error") #åœ¨ç¬¬ 4 è±¡é™æ‰¾ä¸åˆ°è§£"
    return valid[0]    


"""
import math

def solve_joint(d_ori, d_J, Jx, Jy):
    """
    è¨ˆç®—äº¤é»åº§æ¨™ (xp, yp)
    d_ori: é»åˆ°åŸé» (0,0) çš„è·é›¢ (r)
    d_J:   é»åˆ° J é» (Jx, Jy) çš„è·é›¢ (R)
    Jx, Jy: J é»çš„åº§æ¨™
    """
    # 1. è¨ˆç®— J é»åˆ°åŸé»è·é›¢çš„å¹³æ–¹ (d^2)
    d2 = Jx**2 + Jy**2
    d = math.sqrt(d2)
    
    # å®‰å…¨æª¢æŸ¥ï¼šå¦‚æœ J é»åœ¨åŸé»ï¼Œæˆ–è·é›¢å¤ªé /å¤ªè¿‘å°è‡´åœ“ä¸ç›¸äº¤ï¼Œå‰‡ç„¡è§£
    if d == 0:
        return None
    
    # 2. æ ¹æ“šé¤˜å¼¦å®šç†æ¨å°å‡ºçš„å¸¸æ•¸é … K
    # K = (r^2 + d^2 - R^2) / 2
    K = (d_ori**2 + d2 - d_J**2) / 2
    
    # 3. è¨ˆç®—åˆ¤åˆ¥å¼ (æª¢æŸ¥åœ“æ˜¯å¦ç›¸äº¤)
    # åˆ¤åˆ¥å¼ = r^2 * d^2 - K^2
    discriminant = (d_ori**2 * d2) - K**2
    
    if discriminant < 0:
        # ä»£è¡¨å…©åœ“ä¸ç›¸äº¤
        return None
    
    sqrt_disc = math.sqrt(discriminant)
    
    # 4. è¨ˆç®—åº§æ¨™ (é€™è£¡æ ¹æ“šä½ çš„åœ–ç¤ºï¼Œå–ç‰¹å®šçš„æ­£è² è™Ÿä»¥ç¬¦åˆ N, F é»çš„ä½ç½®)
    # é€™è£¡çš„å…¬å¼è€ƒæ…®äº†æ—‹è½‰è®Šæ›
    # xp = (K*Jx + Jy*sqrt_disc) / d^2
    # yp = (K*Jy - Jx*sqrt_disc) / d^2
    xp = (K * Jx + Jy * sqrt_disc) / d2
    yp = (K * Jy - Jx * sqrt_disc) / d2
    
    return round(xp, 4), round(yp, 4)

# --- ä½¿ç”¨ç¯„ä¾‹ ---
Jx, Jy = 500, 100  # å‡è¨­ J é»åº§æ¨™

# è¨ˆç®— N é»
pos_N = solve_joint(65.58, 610, Jx, Jy)
# è¨ˆç®— F é»
pos_F = solve_joint(373.38, 610, Jx, Jy)

print(f"N é»åº§æ¨™: {pos_N}")
print(f"F é»åº§æ¨™: {pos_F}")

----------------------------------------------
import math

def get_arc_motion(t, T, Jx, Jy, Nx, Ny, Fx, Fy, R=610):
    """
    t: ç•¶å‰æ™‚é–“
    T: æ“ºå‹•é€±æœŸ
    Jx, Jy: åœ“å¿ƒ J çš„åº§æ¨™
    Nx, Ny: èµ·é» N çš„åº§æ¨™
    Fx, Fy: çµ‚é» F çš„åº§æ¨™
    R: åœ“åŠå¾‘ (é è¨­ 610)
    """
    
    # 1. è¨ˆç®— N é»èˆ‡ F é»ç›¸å°æ–¼åœ“å¿ƒ J çš„è§’åº¦ (å¼§åº¦)
    # atan2(y, x) æœƒè€ƒæ…®è±¡é™ï¼Œå›å‚³ -pi åˆ° pi ä¹‹é–“çš„å€¼
    angle_N = math.atan2(Ny - Jy, Nx - Jx)
    angle_F = math.atan2(Fy - Jy, Fx - Jx)
    
    # è™•ç†è·¨è¶Š -pi/pi é‚Šç•Œçš„æƒ…æ³ (ç¢ºä¿æ“ºå‹•è·¯å¾‘æ˜¯çŸ­å¼§è€Œéé•·å¼§)
    diff = angle_F - angle_N
    if diff > math.pi:
        angle_F -= 2 * math.pi
    elif diff < -math.pi:
        angle_F += 2 * math.pi
        
    # 2. å®šç¾©æ­£å¼¦æ“ºå‹•çš„è§’åº¦å…¬å¼
    # æˆ‘å€‘å¸Œæœ›åœ¨ t=0 æ™‚å¾ä¸­é»é–‹å§‹ï¼Œæˆ–å¯èª¿æ•´ç›¸ä½å¾ N é»é–‹å§‹
    # è‹¥è¦å¾ N é» (èµ·å§‹é») é–‹å§‹ï¼Œå…¬å¼èª¿æ•´ç‚º cos ä¸¦åŠ è² è™Ÿï¼Œæˆ–è€…èª¿æ•´ç›¸ä½
    
    angle_mid = (angle_N + angle_F) / 2
    amplitude = (angle_F - angle_N) / 2
    
    # é€™è£¡ä½¿ç”¨ -cos è®“ t=0 æ™‚é»ä½æ°å¥½åœ¨ N é» (å› ç‚º -cos(0)=-1, angle_mid - amp = angle_N)
    current_angle = angle_mid - amplitude * math.cos((2 * math.pi / T) * t)
    
    # 3. å°‡ç•¶å‰è§’åº¦è½‰å› (x, y) åº§æ¨™
    xt = Jx + R * math.cos(current_angle)
    yt = Jy + R * math.sin(current_angle)
    
    return round(xt, 4), round(yt, 4)

# --- æ¸¬è©¦ç¯„ä¾‹ ---
T = 10  # 10ç§’ä¸€å€‹é€±æœŸ
Jx, Jy = 500, 100
Nx, Ny = 60, -30   # å‡è¨­çš„ N é»
Fx, Fy = 350, -120 # å‡è¨­çš„ F é»

# æ¨¡æ“¬åœ¨ä¸åŒæ™‚é–“é»çš„ä½ç½®
for sec in range(11):
    pos = get_arc_motion(sec, T, Jx, Jy, Nx, Ny, Fx, Fy)
    print(f"æ™‚é–“ {sec}s: åº§æ¨™ {pos}")

é‡é»èªªæ˜

    atan2 çš„é‡è¦æ€§ï¼šä½¿ç”¨ math.atan2(y, x) è€Œé atan(y/x)ï¼Œæ˜¯å› ç‚ºå®ƒèƒ½è‡ªå‹•è™•ç† x=0 çš„æƒ…æ³ï¼Œä¸¦æº–ç¢ºåˆ¤æ–·é»åœ¨åœ“å‘¨ä¸Šçš„å“ªä¸€å€‹è±¡é™ã€‚

    é‚Šç•Œä¿®æ­£ï¼šå¦‚æœ N é»åœ¨ 170âˆ˜ è€Œ F é»åœ¨ âˆ’170âˆ˜ï¼Œå®ƒå€‘ä¹‹é–“å…¶å¯¦åªå·® 20âˆ˜ã€‚ç¨‹å¼ç¢¼ä¸­çš„ diff æª¢æŸ¥ç¢ºä¿é»æ˜¯èµ°ã€ŒçŸ­å¼§ã€è·¯å¾‘ï¼Œä¸æœƒç¹é è·¯ã€‚

    ç›¸ä½å•Ÿå§‹ï¼š

        ç¯„ä¾‹ä¸­ä½¿ç”¨ -amplitude * math.cos(...) æ˜¯ç‚ºäº†è®“ t=0 æ™‚ä½ç½®åœ¨ Nã€‚

        å¦‚æœä½ å¸Œæœ› t=0 æ™‚åœ¨ä¸­é–“å¾€ F ç§»å‹•ï¼Œè«‹æ”¹ç”¨ amplitude * math.sin(...)ã€‚
------------------------------------------
import math

class ArcOscillator:
    def __init__(self, Jx, Jy, R, zones_table):
        self.Jx = Jx
        self.Jy = Jy
        self.R = R
        # zones_table æ ¼å¼: [[r_start, r_end, rel_time], ...]
        self.zones = zones_table
        self.sum_rel_time = sum(z[2] for z in zones_table)
        
    def _get_pos_by_radius(self, r):
        """æ ¹æ“šè·åŸé»åŠå¾‘ rï¼Œè¨ˆç®—åœ¨åŠå¾‘ç‚º Rã€åœ“å¿ƒç‚º J çš„åœ“ä¸Šçš„åº§æ¨™"""
        d2 = self.Jx**2 + self.Jy**2
        K = (r**2 + d2 - self.R**2) / 2
        # åˆ¤åˆ¥å¼æª¢æŸ¥
        disc = (r**2 * d2) - K**2
        if disc < 0: return (0, 0)
        
        # æ ¹æ“šç¤ºæ„åœ–å–å³ä¸‹æ–¹äº¤é»
        sqrt_disc = math.sqrt(disc)
        xp = (K * self.Jx + self.Jy * sqrt_disc) / d2
        yp = (K * self.Jy - self.Jx * sqrt_disc) / d2
        return xp, yp

    def get_position(self, t, T):
        """
        t: ç•¶å‰æ™‚é–“
        T: å–®ç¨‹ (N->F) æ‰€éœ€ç¸½æ™‚é–“
        """
        # 1. å¯¦ç¾ä¾†å›æ“ºå‹• (ä½¿ç”¨ä¸‰è§’æ³¢æ˜ å°„)
        # é€±æœŸç‚º 2*T (N->F->N)
        cycle_t = t % (2 * T)
        if cycle_t > T:
            target_t = 2 * T - cycle_t  # è¿”å›éšæ®µ (F->N)
        else:
            target_t = cycle_t          # å‰é€²éšæ®µ (N->F)
            
        # 2. å°‹æ‰¾ç•¶å‰æ‰€åœ¨çš„ Zone
        elapsed_time = 0
        for r_start, r_end, rel_t in self.zones:
            zone_duration = (rel_t / self.sum_rel_time) * T
            
            if elapsed_time <= target_t <= (elapsed_time + zone_duration + 1e-9):
                # è¨ˆç®—åœ¨è©² Zone å…§çš„é€²åº¦æ¯”ä¾‹ (0~1)
                local_ratio = (target_t - elapsed_time) / zone_duration
                # åœ¨èµ·å§‹åŠå¾‘èˆ‡çµæŸåŠå¾‘é–“åšç·šæ€§æ’å€¼
                # æ³¨æ„ï¼šé€™æ˜¯åœ¨åŠå¾‘ç©ºé–“ç­‰é€Ÿï¼Œè‹¥è¦åš´æ ¼è§’åº¦ç­‰é€Ÿï¼Œå¯å…ˆè½‰è§’åº¦å†æ’å€¼
                current_r = r_start + (r_end - r_start) * local_ratio
                return self._get_pos_by_radius(current_r)
            
            elapsed_time += zone_duration
            
        return self._get_pos_by_radius(self.zones[-1][1])

# --- åˆå§‹åŒ–è³‡æ–™ ---
# ä¾ç…§åœ–ç‰‡è¼¸å…¥: zone_num, r_start, r_end, relative_time
data = [
    [68.58, 92.03, 1], [92.03, 115.47, 1], [115.47, 138.92, 2],
    [138.92, 162.36, 2], [162.36, 185.81, 3], [185.81, 209.26, 3],
    [209.26, 232.70, 3], [232.70, 256.15, 3], [256.15, 279.60, 3],
    [279.60, 303.04, 2], [303.04, 326.49, 2], [326.49, 349.93, 1],
    [349.93, 373.38, 1]
]

# å‡è¨­ J é»åœ¨ (500, 200), R = 610
oscillator = ArcOscillator(Jx=500, Jy=200, R=610, zones_table=data)

# æ¸¬è©¦ï¼šå‡è¨­å–®ç¨‹ T = 4 ç§’ï¼Œè¨ˆç®— t = 5 ç§’ (å›ç¨‹ä¸­) çš„ä½ç½®
pos = oscillator.get_position(t=5, T=4)
print(f"t=5s (å›ç¨‹) çš„åº§æ¨™: {pos}")
"""

K_INIT_X, K_INIT_Y = 450.0, -420.0          # K é»èµ·å§‹åº§æ¨™               # 45Â° é€†æ™‚é‡
J_INIT_X, J_INIT_Y = calc_axis_rot(K_INIT_X, K_INIT_Y, 45)
D_ININ_X, D_ININ_Y = solve_joint(Disk_Near_ini, J_INIT_X, J_INIT_Y, name="D_N")
D_INIF_X, D_INIF_Y = solve_joint(Disk_Far_ini, J_INIT_X, J_INIT_Y, name="D_F")



for step in range(STEPS_TOTAL):
    # ---- Platen (black) ----
    ang_pl = 90 + step * deg_per_step_platen
    rad_pl = math.radians(ang_pl)
    pl_x.append(PLATEN_RADIUS * math.cos(rad_pl))
    pl_y.append(PLATEN_RADIUS * math.sin(rad_pl))
    
    # ---- common angular part (used for both pendulum modes) ----
    phi = 2.0 * math.pi * WAFER_PENDULUM_FREQ * step   # phase

    # ---- radius according to selected mode ----
    if st.session_state.PEND_MODE == "Sine":
        # sinusoidal motion between NEAR and FAR
        r_t = WAFER_MID - WAFER_AMP * math.cos(phi)
    else:   # Custom â€“ linear backâ€‘andâ€‘forth (triangular wave)
        # normalise step into [0, 2) where 0â€‘1 = forward, 1â€‘2 = backward
        period_norm = (step * WAFER_PENDULUM_FREQ) % 2.0
        if period_norm <= 1.0:          # forward
            r_t = WAFER_NEAR + (WAFER_FAR - WAFER_NEAR) * period_norm
        else:                           # backward
            r_t = WAFER_FAR - (WAFER_FAR - WAFER_NEAR) * (period_norm - 1.0)

    # ---- rotate the whole centre clockwise (same as before) ----
    rad_wa = math.radians( 90 - step * deg_per_step_platen)   # clockwise
    wa_x = r_t * math.cos(rad_wa)      # current centre x (float)
    wa_y = r_t * math.sin(rad_wa)      # current centre y (float)

    # store centre for later drawing
    wa_x_traj.append(wa_x)
    wa_y_traj.append(wa_y)

    # ---- PointA (blue) ----
    ang_a1 = step * deg_per_step_pointa + 180 
    rad_a1 = math.radians(ang_a1)
    pa_x.append(wa_x + st.session_state.POINTA_RADIUS * math.cos(rad_a1-rad_pl))
    pa_y.append(wa_y + st.session_state.POINTA_RADIUS * math.sin(rad_a1-rad_pl))

    # ---- PointA2 (green, opposite side) ----
    ang_a2 = ang_a1 + 180.0
    rad_a2 = math.radians(ang_a2)
    pa2_x.append(wa_x + st.session_state.POINTA_RADIUS * math.cos(rad_a2-rad_pl))
    pa2_y.append(wa_y + st.session_state.POINTA_RADIUS * math.sin(rad_a2-rad_pl))

    # ---- Kã€J é»çš„æ—‹è½‰ (èˆ‡ Platen åŒ RPMã€é †æ™‚é‡) ----
    #   Platen é€†æ™‚é‡ +deg_per_step_platenï¼Œæ•…é †æ™‚é‡éœ€å–è² è™Ÿ
    rot_angle = math.radians(-step * deg_per_step_platen)   # clockwise
    k_x.append(K_INIT_X * math.cos(rot_angle) - K_INIT_Y * math.sin(rot_angle))
    k_y.append(K_INIT_X * math.sin(rot_angle) + K_INIT_Y * math.cos(rot_angle))
    j_x.append(J_INIT_X * math.cos(rot_angle) - J_INIT_Y * math.sin(rot_angle))
    j_y.append(J_INIT_X * math.sin(rot_angle) + J_INIT_Y * math.cos(rot_angle))
    disk_n_x.append(D_ININ_X * math.cos(rot_angle) - D_ININ_Y * math.sin(rot_angle))
    disk_n_y.append(D_ININ_X * math.sin(rot_angle) + D_ININ_Y * math.cos(rot_angle))
    disk_f_x.append(D_INIF_X * math.cos(rot_angle) - D_INIF_Y * math.sin(rot_angle))
    disk_f_y.append(D_INIF_X * math.sin(rot_angle) + D_INIF_Y * math.cos(rot_angle))


    # Platen and Wafer rotate with the same angular speed (deg_per_step_platen)
    revo_platen = (step * deg_per_step_platen) / 360.0   # float
    revo_pointa = (step * deg_per_step_pointa) / 360.0   # float
    platen_rev.append(revo_platen)          # for the Platen
    wafer_rev.append(revo_pointa)           # for the Waferâ€‘center
    
    # ---- distance from origin (for the XYâ€‘distance plot) ----
    dist_a1.append(math.hypot(pa_x[-1], pa_y[-1]))
    dist_a2.append(math.hypot(pa2_x[-1], pa2_y[-1]))
    dist_wa.append(math.hypot(wa_x, wa_y))


    show_green = st.session_state.SHOW_GREEN          # read once
    green_color = "green" if show_green else "rgba(0,0,0,0)"
    green_width = 1 if show_green else 0

# -------------------------------------------------
# 7ï¸âƒ£  Build Plotly figure
# -------------------------------------------------
fig = make_subplots(
    rows=2,
    cols=1,
    vertical_spacing= 0.1 ,
    row_heights=[0.9, 0.3],
    specs=[
        [{'type': 'scatter'}],   
        [{'type': 'scatter'}]  
    ]
)

# background reference circle
fig.add_shape(
    type="circle",
    xref="x", yref="y",
    x0=-PLATEN_RADIUS, y0=-PLATEN_RADIUS,
    x1= PLATEN_RADIUS, y1= PLATEN_RADIUS,
    line_color="rgba(0,0,0,0.5)",
    fillcolor="rgba(0,0,0,0)",
)

fig.add_shape(
    type="circle",
    xref="x", yref="y",
    x0=-150, y0= WAFER_NEAR-150,
    x1= 150, y1= WAFER_NEAR+150,
    line_color="rgba(0,0,0,0.5)",
    fillcolor="rgba(0,0,0,0)",
)

# ---- initial points (show last step so slider starts at the rightmost position) ----
last = STEPS_TOTAL - 1
fig.add_trace(
    go.Scatter(
        name="Points",
        x=[pa_x[last], pl_x[last], wa_x_traj[last], pa2_x[last]],
        y=[pa_y[last], pl_y[last], wa_y_traj[last], pa2_y[last]],
        mode="markers",
        marker=dict(
            size=[5, 5, 5, 5],
            color=["blue", "black", "black", green_color],
        ),
    ),row=1, col=1
)

# Empty traces that will be filled frameâ€‘byâ€‘frame (prevents sending all data at once)
fig.add_trace(go.Scatter(name="A1 traj", x=[], y=[], mode="lines",
                         line=dict(color="blue", width=1)))
fig.add_trace(go.Scatter(name="Platen traj", x=[], y=[], mode="lines",
                         line=dict(color="black", width=1)))
fig.add_trace(go.Scatter(name="Wafer traj", x=[], y=[], mode="lines",
                         line=dict(color="black", width=1, dash="dot")))
fig.add_trace(go.Scatter(name="A2 traj", x=[], y=[], mode="lines",
                         line=dict(color=green_color, width=green_width)))

# orange line that connects Green â†’ Black â†’ Blue (three points)
fig.add_trace(go.Scatter(name="A1â€‘A2", x=[], y=[], mode="lines",
                         line=dict(color="orange", width=1)))
# ---------- æ–°å¢ Kã€Jã€DNã€DF çš„ trace (åªé¡¯ç¤ºæœ€å¾Œä¸€æ­¥) ----------
fig.add_trace(
    go.Scatter(
        name="K point",
        x=[k_x[last]],
        y=[k_y[last]],
        mode="markers",
        marker=dict(size=5, color="magenta")
    ),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(
        name="J point",
        x=[j_x[last]],
        y=[j_y[last]],
        mode="markers",
        marker=dict(size=5, color="cyan")
    ),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(
        name="DN point",
        x=[disk_n_x[last]],
        y=[disk_n_y[last]],
        mode="markers",
        marker=dict(size=5, color="orange")
    ),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(
        name="DF point",
        x=[disk_f_x[last]],
        y=[disk_f_y[last]],
        mode="markers",
        marker=dict(size=5, color="red")
    ),
    row=1, col=1
)


#--------------------below
fig.add_trace(go.Scatter(name="Dist A1", x=[], y=[], mode="lines+markers",
                         line=dict(color="blue", width=2), marker=dict(size=4)),
               row=2, col=1)
fig.add_trace(go.Scatter(name="Dist A2", x=[], y=[], mode="lines+markers",
                         line=dict(color="green", width=2), marker=dict(size=4)),
               row=2, col=1)
fig.add_trace(go.Scatter(name="Dist Wafer", x=[], y=[], mode="lines+markers",
                         line=dict(color="black", width=2, dash="dot"),
                         marker=dict(size=4)),
               row=2, col=1)

# -------------------------------------------------
# 8ï¸âƒ£  Create animation frames
# -------------------------------------------------
frames = []
for i in range(STEPS_TOTAL):
    times = [k * STEP_SEC for k in range(i + 1)]
    frames.append(
        go.Frame(
            name=str(i),
            data=[
                # points (blue, black, blackâ€‘wafer, green)
                go.Scatter(
                    x=[pa_x[i], pl_x[i], wa_x_traj[i], pa2_x[i]],
                    y=[pa_y[i], pl_y[i], wa_y_traj[i], pa2_y[i]],
                    mode="markers",
                    marker=dict(
                        size=[5, 5, 5, 5],
                        color=["blue", "black", "black", green_color],
                    ),
                ),
                # trajectories up to current step
                go.Scatter(x=pa_x[: i + 1], y=pa_y[: i + 1],
                           mode="lines", line=dict(color="blue", width=2, shape="spline", smoothing=1.3)),
                go.Scatter(x=pl_x[: i + 1], y=pl_y[: i + 1],
                           mode="lines", line=dict(color="black", width=1, shape="spline", smoothing=1.3)),
                go.Scatter(x=wa_x_traj[: i + 1], y=wa_y_traj[: i + 1],
                           mode="lines", line=dict(color="black", width=1, shape="spline", smoothing=1.3, dash="dot")),
                go.Scatter(x=pa2_x[: i + 1], y=pa2_y[: i + 1],
                           mode="lines", line=dict(color=green_color, width=green_width, shape="spline", smoothing=1.3)),
                # orange line: Green  â†’ Blue (three points)
                go.Scatter(
                    x=[pa2_x[i], pa_x[i]],
                    y=[pa2_y[i], pa_y[i]],
                    mode="lines",
                    line=dict(color="orange", width=1, shape="spline", smoothing=1.3),
                ),
                
                # 6. K é»
                go.Scatter(
                    x=[k_x[i]],
                    y=[k_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="magenta"),
                ),
                # 7. J é»
                go.Scatter(
                    x=[j_x[i]],
                    y=[j_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="cyan"),
                ),
                               
                # 8. DN é»
                go.Scatter(
                    x=[disk_n_x[i]],
                    y=[disk_n_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="orange"),
                ),
                # 9. DF é»
                go.Scatter(
                    x=[disk_f_x[i]],
                    y=[disk_f_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="red"),
                ),

                # Dist A1
                go.Scatter(
                    x=times,
                    y=dist_a1[: i + 1],
                    mode="lines+markers",
                    line=dict(color="blue", width=1, shape="spline", smoothing=1.3),
                    marker=dict(size=4),
                ),
                # Dist A2
                go.Scatter(
                    x=times,
                    y=dist_a2[: i + 1],
                    mode="lines+markers",
                    line=dict(color="green", width=1, shape="spline", smoothing=1.3),
                    marker=dict(size=4),
                ),
                # Dist Wafer
                go.Scatter(
                    x=times,
                    y=dist_wa[: i + 1],
                    mode="lines+markers",
                    line=dict(color="black", width=1, shape="spline", smoothing=1.3, dash="dot"),
                    marker=dict(size=4),
                ),
            ],
          
            layout=go.Layout(
                annotations=[
                    dict(
                        x=0.02, y=0.95,
                        xref="paper", yref="paper",
                        text=(
                            f"Platen âŸ³: {platen_rev[i]:.1f}  |  "
                            f"Wafer âŸ³: {wafer_rev[i]:.1f}"
                        ),
                        showarrow=False,
                        font=dict(size=12, color="black"),
                        bgcolor="rgba(255,255,255,0.7)",
                        bordercolor="black",
                        borderwidth=1,
                        align="left",
                    )
                ]
            ),
            traces=[0, 1, 2, 3, 4, 5, 6, 7, 8],   
        )
    )
fig.frames = frames

# -------------------------------------------------
# 9ï¸âƒ£  Slider & Play / Pause controls
# -------------------------------------------------
sliders = [{
    "active": last,
    "currentvalue": {"prefix": "sec: "},
    "pad": {"t": 50},
    "steps": [{
        "method": "animate",
        "args": [[str(k)], {"mode": "immediate",
                           "frame": {"duration": 0},
                           "transition": {"duration": 0}}],
         "label": f"{k * STEP_SEC:.2f}"
    } for k in range(STEPS_TOTAL)]
}]

updatemenus = [{
    "type": "buttons", "direction": "left",
    "buttons": [
        {"label": "â–¶ Play", "method": "animate",
         "args": [None,
                  {"frame": {"duration": 80, "redraw": True},
                   "fromcurrent": True,
                   "transition": {"duration": 0},
                   "mode": "immediate"}]},
        {"label": "âšâš Pause", "method": "animate",
         "args": [[None], {"mode": "immediate"}]}
    ],
    "pad": {"r": 10, "t": 10},
    "showactive": False,
    "x": 0.1, "y": 0,
    "xanchor": "right", "yanchor": "top"
}]

# -------------------------------------------------
# 10ï¸âƒ£ Layout â€“ axes ranges for both subâ€‘plots
# -------------------------------------------------
max_dist = max(max(dist_a1), max(dist_a2), max(dist_wa)) * 1.1   # 10% margin

fig.update_layout(
    width=1000, height=1000,
        sliders=sliders,
    updatemenus=updatemenus,
   
    xaxis=dict(
        range=[-PLATEN_RADIUS - 35, PLATEN_RADIUS + 35],
        zeroline=False, showgrid=True, scaleanchor="y", title="X (mm)"
    ),
    yaxis=dict(
        range=[-PLATEN_RADIUS - 35, PLATEN_RADIUS + 35],
        showgrid=True, title="Y (mm)"
    ),
    
    xaxis2=dict(
        range=[0, (STEPS_TOTAL*STEP_SEC)],
        title="Sec"
    ),
    yaxis2=dict(
        range=[0, max_dist],
        title="Distance(mm)"
    ),
    margin=dict(l=40, r=40, t=60, b=40),
)


# -------------------------------------------------
# ğŸ”Ÿ  Display the chart
# -------------------------------------------------

st.plotly_chart(fig, use_container_width=False)





