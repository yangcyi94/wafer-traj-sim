import streamlit as st
import plotly.graph_objects as go
from plotly.subplots import make_subplots 
import math
from sympy import symbols, Eq, solve, N
import pandas as pd

# -------------------------------------------------
# 1ï¸âƒ£  Default sessionâ€‘state values (run only once)
# -------------------------------------------------
if "STEP_SEC" not in st.session_state:
    st.session_state.STEP_SEC = 0.02          # seconds per step
if "TOTAL_TIME" not in st.session_state:
    st.session_state.TOTAL_TIME = 10         # total simulation time (seconds)
if "PLATEN_RPM" not in st.session_state:
    st.session_state.PLATEN_RPM = 86
if "POINTA_RPM" not in st.session_state:
    st.session_state.POINTA_RPM = 92
if "POINTA_RADIUS" not in st.session_state:
    st.session_state.POINTA_RADIUS = 100

# pendulumâ€‘related defaults
if "SWEEP_START" not in st.session_state:
    st.session_state.SWEEP_START = 7.2      # inch
if "SWEEP_END" not in st.session_state:
    st.session_state.SWEEP_END   = 8.2      # inch
if "SWPS_MIN" not in st.session_state:
    st.session_state.SWPS_MIN    = 13
if "PEND_MODE" not in st.session_state:
    st.session_state.PEND_MODE   = "Sine"   # or "Custom"

# -------------------------------------------------
# 2ï¸âƒ£  Sidebar input form
# -------------------------------------------------
st.sidebar.header("Setting")
with st.sidebar.form(key="param_form"):
    st.session_state.PLATEN_RPM = st.number_input(
        "Platen RPM", min_value=0, max_value=200, value=st.session_state.PLATEN_RPM, step=1
    )
    st.session_state.POINTA_RPM = st.number_input(
        "Head RPM", min_value=0, max_value=200, value=st.session_state.POINTA_RPM, step=1
    )
    st.session_state.POINTA_RADIUS = st.number_input(
        "PointA Radius (mm)", min_value=1, max_value=150, value=st.session_state.POINTA_RADIUS, step=1
    )
    st.session_state.STEP_SEC = st.slider(
        "second per STEP", min_value=0.01, max_value=0.1,
        value=st.session_state.STEP_SEC, step=0.01, format="%.2f"
    )
    st.session_state.TOTAL_TIME = st.slider(
        "TOTAL_TIME (s)", min_value=1, max_value=99,
        value=int(st.session_state.TOTAL_TIME), step=1
    )
    st.session_state.SWEEP_START = st.slider(
        "Sweep START (inch)", min_value=6.0, max_value=7.3,
        value=float(st.session_state.SWEEP_START), step=0.1, format="%.2f"
    )
    st.session_state.SWEEP_END = st.slider(
        "Sweep END (inch)", min_value=8.0, max_value=8.4,
        value=float(st.session_state.SWEEP_END), step=0.1, format="%.2f"
    )
    st.session_state.SWPS_MIN = st.slider(
        "Swps per minute", min_value=13, max_value=20,
        value=int(st.session_state.SWPS_MIN), step=1
    )
    st.session_state.PEND_MODE = st.selectbox(
        "Sweep mode", options=["Sine", "Custom(1)"],
        index=0 if st.session_state.PEND_MODE == "Sine" else 1
    )
    st.session_state.SHOW_GREEN = st.checkbox(
    "Show point 2",
    value=True,
    key="show_green_checkbox"
    )
    submitted = st.form_submit_button("Update")
    if submitted:
        st.session_state.show_plot = True   # flag to draw the figure

# -------------------------------------------------
# 3ï¸âƒ£  Placeholder / info (before Update)
# -------------------------------------------------
if not st.session_state.get("show_plot", False):
    st.info(
        "Set the parameters on the left sidebar and click **Update** to generate the plot.\n"
        "âš ï¸ If second_per_STEP is very small or TOTAL_TIME is large, many points will be created "
        "and rendering may take several mins."
    )
    st.stop()   # stop execution until the user clicks Update

# -------------------------------------------------
# 4ï¸âƒ£  Derived constants
# -------------------------------------------------
STEP_SEC   = st.session_state.STEP_SEC
TOTAL_TIME = st.session_state.TOTAL_TIME
STEPS_TOTAL = int(TOTAL_TIME / STEP_SEC) + 1   # +1 so the final time is included

if STEPS_TOTAL > 1000:
    st.warning(
        "âš ï¸over 1000 steps --- "
        "please retry with SMALLER total_time or BIGGER second_per_step.")
    st.stop() 

# degrees added each step (RPM Ã— 6Â°/s Ã— STEP_SEC)
deg_per_step_platen = st.session_state.PLATEN_RPM * 6.0 * STEP_SEC
deg_per_step_pointa = st.session_state.POINTA_RPM * 6.0 * STEP_SEC

# pendulum frequency (swings per minute â†’ cycles per step)
WAFER_PENDULUM_FREQ = st.session_state.SWPS_MIN * STEP_SEC / 30

# waferâ€‘center sweep range (inch â†’ mm)
WAFER_NEAR = st.session_state.SWEEP_START * 2.54 * 10   # mm
WAFER_FAR  = st.session_state.SWEEP_END   * 2.54 * 10   # mm
WAFER_MID  = (WAFER_NEAR + WAFER_FAR) / 2.0
WAFER_AMP  = (WAFER_FAR - WAFER_NEAR) / 2.0

PLATEN_RADIUS = 390   

Disk_Near_ini = 2.7 * 25.4   # 68.58 mm
Disk_Far_ini = 14.7 * 25.4  # 373.38 mm

# -------------------------------------------------
# 5ï¸âƒ£  Containers for all points
# -------------------------------------------------
pa_x, pa_y   = [], []          # blue PointA
pa2_x, pa2_y = [], []          # green PointA2 (opposite side)
pl_x, pl_y   = [], []          # black Platen
wa_x_traj, wa_y_traj = [], []  # waferâ€‘center trajectory (list of floats)
platen_rev = []   # Platen revolutions (float, 1â€‘decimal)
wafer_rev  = []   # Waferâ€‘center revolutions (float, 1â€‘decimal)

# distanceâ€‘vsâ€‘step data (distance from origin)
dist_a1, dist_a2, dist_wa = [], [], []   # each list length = STEPS_TOTAL


k_x, k_y = [], []          # K ì  ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
j_x, j_y = [], []          # J ì  ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
disk_n_x, disk_n_y= [], []
disk_f_x, disk_f_y= [], []        

# -------------------------------------------------
# 6ï¸âƒ£  Main loop â€“ compute every step
# -------------------------------------------------

def calc_axis_rot(x, y, deg=45):
    rad = math.radians(deg)
    cos_a, sin_a = math.cos(rad), math.sin(rad)
    x_p = x * cos_a - y * sin_a
    y_p = x * sin_a + y * cos_a
    return x_p, y_p

def solve_joint(r, Xx, Xy, name="J"):
    x, y = symbols('x y', real=True)
    eq1 = Eq(x**2 + y**2, r**2)
    eq2 = Eq((x - Xx)**2 + (y - Xy)**2, 610**2)
    sol = solve((eq1, eq2), (x, y), dict=True)
    valid = []
    for s in sol:
        xv = N(s[x])
        yv = N(s[y])
        if xv > 0 and yv < 0:            
            valid.append((float(xv), float(yv)))
    if not valid:
        raise ValueError(f"{name} error") #åœ¨ç¬¬ 4 è±¡é™æ‰¾ä¸åˆ°è§£"
    return valid[0]    

K_INIT_X, K_INIT_Y = 450.0, -420.0          # K é»žèµ·å§‹åº§æ¨™               # 45Â° é€†æ™‚é‡
J_INIT_X, J_INIT_Y = calc_axis_rot(K_INIT_X, K_INIT_Y, 45)
D_ININ_X, D_ININ_Y = solve_joint(Disk_Near_ini, J_INIT_X, J_INIT_Y, name="D_N")
D_INIF_X, D_INIF_Y = solve_joint(Disk_Far_ini, J_INIT_X, J_INIT_Y, name="D_F")



for step in range(STEPS_TOTAL):
    # ---- Platen (black) ----
    ang_pl = 90 + step * deg_per_step_platen
    rad_pl = math.radians(ang_pl)
    pl_x.append(PLATEN_RADIUS * math.cos(rad_pl))
    pl_y.append(PLATEN_RADIUS * math.sin(rad_pl))
    
    # ---- common angular part (used for both pendulum modes) ----
    phi = 2.0 * math.pi * WAFER_PENDULUM_FREQ * step   # phase

    # ---- radius according to selected mode ----
    if st.session_state.PEND_MODE == "Sine":
        # sinusoidal motion between NEAR and FAR
        r_t = WAFER_MID - WAFER_AMP * math.cos(phi)
    else:   # Custom â€“ linear backâ€‘andâ€‘forth (triangular wave)
        # normalise step into [0, 2) where 0â€‘1 = forward, 1â€‘2 = backward
        period_norm = (step * WAFER_PENDULUM_FREQ) % 2.0
        if period_norm <= 1.0:          # forward
            r_t = WAFER_NEAR + (WAFER_FAR - WAFER_NEAR) * period_norm
        else:                           # backward
            r_t = WAFER_FAR - (WAFER_FAR - WAFER_NEAR) * (period_norm - 1.0)

    # ---- rotate the whole centre clockwise (same as before) ----
    rad_wa = math.radians( 90 - step * deg_per_step_platen)   # clockwise
    wa_x = r_t * math.cos(rad_wa)      # current centre x (float)
    wa_y = r_t * math.sin(rad_wa)      # current centre y (float)

    # store centre for later drawing
    wa_x_traj.append(wa_x)
    wa_y_traj.append(wa_y)

    # ---- PointA (blue) ----
    ang_a1 = step * deg_per_step_pointa + 180 
    rad_a1 = math.radians(ang_a1)
    pa_x.append(wa_x + st.session_state.POINTA_RADIUS * math.cos(rad_a1-rad_pl))
    pa_y.append(wa_y + st.session_state.POINTA_RADIUS * math.sin(rad_a1-rad_pl))

    # ---- PointA2 (green, opposite side) ----
    ang_a2 = ang_a1 + 180.0
    rad_a2 = math.radians(ang_a2)
    pa2_x.append(wa_x + st.session_state.POINTA_RADIUS * math.cos(rad_a2-rad_pl))
    pa2_y.append(wa_y + st.session_state.POINTA_RADIUS * math.sin(rad_a2-rad_pl))

    # ---- Kã€J é»žçš„æ—‹è½‰ (èˆ‡ Platen åŒ RPMã€é †æ™‚é‡) ----
    #   Platen é€†æ™‚é‡ +deg_per_step_platenï¼Œæ•…é †æ™‚é‡éœ€å–è² è™Ÿ
    rot_angle = math.radians(-step * deg_per_step_platen)   # clockwise
    k_x.append(K_INIT_X * math.cos(rot_angle) - K_INIT_Y * math.sin(rot_angle))
    k_y.append(K_INIT_X * math.sin(rot_angle) + K_INIT_Y * math.cos(rot_angle))
    j_x.append(J_INIT_X * math.cos(rot_angle) - J_INIT_Y * math.sin(rot_angle))
    j_y.append(J_INIT_X * math.sin(rot_angle) + J_INIT_Y * math.cos(rot_angle))
    disk_n_x.append(D_ININ_X * math.cos(rot_angle) - D_ININ_Y * math.sin(rot_angle))
    disk_n_y.append(D_ININ_X * math.sin(rot_angle) + D_ININ_Y * math.cos(rot_angle))
    disk_f_x.append(D_INIF_X * math.cos(rot_angle) - D_INIF_Y * math.sin(rot_angle))
    disk_f_y.append(D_INIF_X * math.sin(rot_angle) + D_INIF_Y * math.cos(rot_angle))


    # Platen and Wafer rotate with the same angular speed (deg_per_step_platen)
    revo_platen = (step * deg_per_step_platen) / 360.0   # float
    revo_pointa = (step * deg_per_step_pointa) / 360.0   # float
    platen_rev.append(revo_platen)          # for the Platen
    wafer_rev.append(revo_pointa)           # for the Waferâ€‘center
    
    # ---- distance from origin (for the XYâ€‘distance plot) ----
    dist_a1.append(math.hypot(pa_x[-1], pa_y[-1]))
    dist_a2.append(math.hypot(pa2_x[-1], pa2_y[-1]))
    dist_wa.append(math.hypot(wa_x, wa_y))


    show_green = st.session_state.SHOW_GREEN          # read once
    green_color = "green" if show_green else "rgba(0,0,0,0)"
    green_width = 1 if show_green else 0

# -------------------------------------------------
# 7ï¸âƒ£  Build Plotly figure
# -------------------------------------------------
fig = make_subplots(
    rows=2,
    cols=1,
    vertical_spacing= 0.1 ,
    row_heights=[0.9, 0.3],
    specs=[
        [{'type': 'scatter'}],   
        [{'type': 'scatter'}]  
    ]
)

# background reference circle
fig.add_shape(
    type="circle",
    xref="x", yref="y",
    x0=-PLATEN_RADIUS, y0=-PLATEN_RADIUS,
    x1= PLATEN_RADIUS, y1= PLATEN_RADIUS,
    line_color="rgba(0,0,0,0.5)",
    fillcolor="rgba(0,0,0,0)",
)

fig.add_shape(
    type="circle",
    xref="x", yref="y",
    x0=-150, y0= WAFER_NEAR-150,
    x1= 150, y1= WAFER_NEAR+150,
    line_color="rgba(0,0,0,0.5)",
    fillcolor="rgba(0,0,0,0)",
)

# ---- initial points (show last step so slider starts at the rightmost position) ----
last = STEPS_TOTAL - 1
fig.add_trace(
    go.Scatter(
        name="Points",
        x=[pa_x[last], pl_x[last], wa_x_traj[last], pa2_x[last]],
        y=[pa_y[last], pl_y[last], wa_y_traj[last], pa2_y[last]],
        mode="markers",
        marker=dict(
            size=[5, 5, 5, 5],
            color=["blue", "black", "black", green_color],
        ),
    ),row=1, col=1
)

# Empty traces that will be filled frameâ€‘byâ€‘frame (prevents sending all data at once)
fig.add_trace(go.Scatter(name="A1 traj", x=[], y=[], mode="lines",
                         line=dict(color="blue", width=1)))
fig.add_trace(go.Scatter(name="Platen traj", x=[], y=[], mode="lines",
                         line=dict(color="black", width=1)))
fig.add_trace(go.Scatter(name="Wafer traj", x=[], y=[], mode="lines",
                         line=dict(color="black", width=1, dash="dot")))
fig.add_trace(go.Scatter(name="A2 traj", x=[], y=[], mode="lines",
                         line=dict(color=green_color, width=green_width)))

# orange line that connects Green â†’ Black â†’ Blue (three points)
fig.add_trace(go.Scatter(name="A1â€‘A2", x=[], y=[], mode="lines",
                         line=dict(color="orange", width=1)))
# ---------- æ–°å¢ž Kã€Jã€DNã€DF çš„ trace (åªé¡¯ç¤ºæœ€å¾Œä¸€æ­¥) ----------
fig.add_trace(
    go.Scatter(
        name="K point",
        x=[k_x[last]],
        y=[k_y[last]],
        mode="markers",
        marker=dict(size=5, color="magenta")
    ),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(
        name="J point",
        x=[j_x[last]],
        y=[j_y[last]],
        mode="markers",
        marker=dict(size=5, color="cyan")
    ),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(
        name="DN point",
        x=[disk_n_x[last]],
        y=[disk_n_y[last]],
        mode="markers",
        marker=dict(size=5, color="orange")
    ),
    row=1, col=1
)
fig.add_trace(
    go.Scatter(
        name="DF point",
        x=[disk_f_x[last]],
        y=[disk_f_y[last]],
        mode="markers",
        marker=dict(size=5, color="red")
    ),
    row=1, col=1
)


#--------------------below
fig.add_trace(go.Scatter(name="Dist A1", x=[], y=[], mode="lines+markers",
                         line=dict(color="blue", width=2), marker=dict(size=4)),
               row=2, col=1)
fig.add_trace(go.Scatter(name="Dist A2", x=[], y=[], mode="lines+markers",
                         line=dict(color="green", width=2), marker=dict(size=4)),
               row=2, col=1)
fig.add_trace(go.Scatter(name="Dist Wafer", x=[], y=[], mode="lines+markers",
                         line=dict(color="black", width=2, dash="dot"),
                         marker=dict(size=4)),
               row=2, col=1)

# -------------------------------------------------
# 8ï¸âƒ£  Create animation frames
# -------------------------------------------------
frames = []
for i in range(STEPS_TOTAL):
    times = [k * STEP_SEC for k in range(i + 1)]
    frames.append(
        go.Frame(
            name=str(i),
            data=[
                # points (blue, black, blackâ€‘wafer, green)
                go.Scatter(
                    x=[pa_x[i], pl_x[i], wa_x_traj[i], pa2_x[i]],
                    y=[pa_y[i], pl_y[i], wa_y_traj[i], pa2_y[i]],
                    mode="markers",
                    marker=dict(
                        size=[5, 5, 5, 5],
                        color=["blue", "black", "black", green_color],
                    ),
                ),
                # trajectories up to current step
                go.Scatter(x=pa_x[: i + 1], y=pa_y[: i + 1],
                           mode="lines", line=dict(color="blue", width=2, shape="spline", smoothing=1.3)),
                go.Scatter(x=pl_x[: i + 1], y=pl_y[: i + 1],
                           mode="lines", line=dict(color="black", width=1, shape="spline", smoothing=1.3)),
                go.Scatter(x=wa_x_traj[: i + 1], y=wa_y_traj[: i + 1],
                           mode="lines", line=dict(color="black", width=1, shape="spline", smoothing=1.3, dash="dot")),
                go.Scatter(x=pa2_x[: i + 1], y=pa2_y[: i + 1],
                           mode="lines", line=dict(color=green_color, width=green_width, shape="spline", smoothing=1.3)),
                # orange line: Green  â†’ Blue (three points)
                go.Scatter(
                    x=[pa2_x[i], pa_x[i]],
                    y=[pa2_y[i], pa_y[i]],
                    mode="lines",
                    line=dict(color="orange", width=1, shape="spline", smoothing=1.3),
                ),
                
                # 6. K é»ž
                go.Scatter(
                    x=[k_x[i]],
                    y=[k_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="magenta"),
                ),
                # 7. J é»ž
                go.Scatter(
                    x=[j_x[i]],
                    y=[j_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="cyan"),
                ),
                               
                # 8. DN é»ž
                go.Scatter(
                    x=[disk_n_x[i]],
                    y=[disk_n_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="orange"),
                ),
                # 9. DF é»ž
                go.Scatter(
                    x=[disk_f_x[i]],
                    y=[disk_f_y[i]],
                    mode="markers",
                    marker=dict(size=5, color="red"),
                ),

                # Dist A1
                go.Scatter(
                    x=times,
                    y=dist_a1[: i + 1],
                    mode="lines+markers",
                    line=dict(color="blue", width=1, shape="spline", smoothing=1.3),
                    marker=dict(size=4),
                ),
                # Dist A2
                go.Scatter(
                    x=times,
                    y=dist_a2[: i + 1],
                    mode="lines+markers",
                    line=dict(color="green", width=1, shape="spline", smoothing=1.3),
                    marker=dict(size=4),
                ),
                # Dist Wafer
                go.Scatter(
                    x=times,
                    y=dist_wa[: i + 1],
                    mode="lines+markers",
                    line=dict(color="black", width=1, shape="spline", smoothing=1.3, dash="dot"),
                    marker=dict(size=4),
                ),
            ],
          
            layout=go.Layout(
                annotations=[
                    dict(
                        x=0.02, y=0.95,
                        xref="paper", yref="paper",
                        text=(
                            f"Platen âŸ³: {platen_rev[i]:.1f}  |  "
                            f"Wafer âŸ³: {wafer_rev[i]:.1f}"
                        ),
                        showarrow=False,
                        font=dict(size=12, color="black"),
                        bgcolor="rgba(255,255,255,0.7)",
                        bordercolor="black",
                        borderwidth=1,
                        align="left",
                    )
                ]
            ),
            traces=[0, 1, 2, 3, 4, 5, 6, 7, 8],   
        )
    )
fig.frames = frames

# -------------------------------------------------
# 9ï¸âƒ£  Slider & Play / Pause controls
# -------------------------------------------------
sliders = [{
    "active": last,
    "currentvalue": {"prefix": "sec: "},
    "pad": {"t": 50},
    "steps": [{
        "method": "animate",
        "args": [[str(k)], {"mode": "immediate",
                           "frame": {"duration": 0},
                           "transition": {"duration": 0}}],
         "label": f"{k * STEP_SEC:.2f}"
    } for k in range(STEPS_TOTAL)]
}]

updatemenus = [{
    "type": "buttons", "direction": "left",
    "buttons": [
        {"label": "â–¶ Play", "method": "animate",
         "args": [None,
                  {"frame": {"duration": 80, "redraw": True},
                   "fromcurrent": True,
                   "transition": {"duration": 0},
                   "mode": "immediate"}]},
        {"label": "âšâš Pause", "method": "animate",
         "args": [[None], {"mode": "immediate"}]}
    ],
    "pad": {"r": 10, "t": 10},
    "showactive": False,
    "x": 0.1, "y": 0,
    "xanchor": "right", "yanchor": "top"
}]

# -------------------------------------------------
# 10ï¸âƒ£ Layout â€“ axes ranges for both subâ€‘plots
# -------------------------------------------------
max_dist = max(max(dist_a1), max(dist_a2), max(dist_wa)) * 1.1   # 10% margin

fig.update_layout(
    width=1000, height=1000,
        sliders=sliders,
    updatemenus=updatemenus,
   
    xaxis=dict(
        range=[-PLATEN_RADIUS - 35, PLATEN_RADIUS + 35],
        zeroline=False, showgrid=True, scaleanchor="y", title="X (mm)"
    ),
    yaxis=dict(
        range=[-PLATEN_RADIUS - 35, PLATEN_RADIUS + 35],
        showgrid=True, title="Y (mm)"
    ),
    
    xaxis2=dict(
        range=[0, (STEPS_TOTAL*STEP_SEC)],
        title="Sec"
    ),
    yaxis2=dict(
        range=[0, max_dist],
        title="Distance(mm)"
    ),
    margin=dict(l=40, r=40, t=60, b=40),
)


# -------------------------------------------------
# ðŸ”Ÿ  Display the chart
# -------------------------------------------------

st.plotly_chart(fig, use_container_width=False)





